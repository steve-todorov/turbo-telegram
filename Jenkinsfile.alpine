@Library('jenkins-shared-libraries') _

def DISTRIBUTION = 'alpine'
def IMAGE_NAME = "strongboxci/" + DISTRIBUTION
def IMAGES = [];
def SNAPSHOT=params.getOrDefault("DEPLOY", false) ? " --snapshot " : ""
def BUILD_ARGS="$SNAPSHOT"
def TIMESTAMP=new Date().getTime()

pipeline {
    agent {
        label "alpine-docker"
    }
    parameters {
        booleanParam defaultValue: false, description: 'Deploy tagged images to docker hub.', name: 'DEPLOY'
    }
    options {
        buildDiscarder logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '50', daysToKeepStr: '', numToKeepStr: '1000')
        timeout(time: 2, unit: 'HOURS')
        disableResume()
        durabilityHint 'PERFORMANCE_OPTIMIZED'
        disableConcurrentBuilds()
        skipDefaultCheckout()
        skipStagesAfterUnstable()
    }
    environment {
      TIMESTAMP = "$TIMESTAMP"
    }
    stages {
        stage('node') {
            steps {
                container("docker") {
                    nodeInfo("docker")
                    checkout scm
                }
            }
        }
        stage('base') {
            when {
                anyOf {
                    triggeredBy cause: "UserIdCause"
                    changeset "images/alpine/Dockerfile.${DISTRIBUTION}"
                }
            }
            steps {
                script {
                    container("docker") {
                        IMAGE = "strongboxci/" + DISTRIBUTION + ":base"

                        sh label: "Building $IMAGE_NAME",
                           script: "/bin/bash ${env.WORKSPACE}/build.sh ${BUILD_ARGS} ./images/$DISTRIBUTION/Dockerfile.$DISTRIBUTION"

                        IMAGES.add(IMAGE)
                    }
                }
            }
        }
        stage('jdk8') {
            when {
                anyOf {
                    // should run upon manual build.
                    triggeredBy cause: "UserIdCause"
                    changeset "images/${DISTRIBUTION}/Dockerfile.${DISTRIBUTION}"
                    changeset "images/${DISTRIBUTION}/jdk8/Dockerfile.${DISTRIBUTION}.*"
                }
            }
            steps {
                container("docker") {
                    script {
                        def files = sh(returnStdout: true, script: '''find ./images/${DISTRIBUTION}/jdk8 -type f -name "*Dockerfile*" | sort | xargs''')
                        processDockerfiles(files)
                    }
                }
            }
        }
        stage('jdk11') {
            when {
                anyOf {
                    // should run upon manual build.
                    triggeredBy cause: "UserIdCause"
                    changeset "images/${DISTRIBUTION}/Dockerfile.${DISTRIBUTION}"
                    changeset "images/${DISTRIBUTION}/jdk11/Dockerfile.${DISTRIBUTION}.*"
                }
            }
            steps {
                container("docker") {
                    script {
                        def files = sh(returnStdout: true, script: '''find ./images/${DISTRIBUTION}/jdk11 -type f -name "*Dockerfile*" | sort | xargs''')
                        processDockerfiles(files)
                    }
                }
            }
        }
        stage('publishing') {
            when {
                anyOf {
                    branch 'master'
                    params.DEPLOY
                }
            }
            steps {
                container("docker") {
                    echo "Deploying images: " + images.toString()
                    withDockerRegistry([credentialsId: dockerCredentials, url: dockerUrl]) {
                        script {
                            IMAGES.each {
                                sh label: "Publishing ${it}...",
                                   script: "docker push ${it}"
                            }
                        }
                    }
                }
            }
        }
    }
}

def processDockerfiles(files) {
    if(files instanceof List) {
        files.split(" ").each {
            println it
            def match = (it =~ /(.*)\\/Dockerfile\.(\w+)(\.(.+))?/)
            if (match.find())
            {
                // DO NOT USE THIS, BECAUSE IT FAILS WITH `"docker build" requires exactly 1 argument.` - LIKELY A BUG!
                // docker.build(IMAGE, '-f ' + it + ' --no-cache .')

                def TAG = match.group(4) ? match.group(4) : 'base'
                def IMAGE = "${IMAGE_NAME}:" + TAG

                sh label: "Building $IMAGE_NAME",
                   script: "/bin/bash ${env.WORKSPACE}/build.sh $it"

                IMAGES.add(IMAGE)
            }
            else
            {
                println "Something went wrong and we could not properly parse ${it} - skipping"
            }
        }
    } else {
        error "processDockerfiles expects argument to be an array, but received " + files.getClass()
    }
}
