@Library('jenkins-shared-libraries') _

def DISTRIBUTION = 'alpine'
def IMAGE_NAME = "strongboxci/" + DISTRIBUTION
def IMAGES = [];

pipeline {
    agent {
        label "alpine-docker"
    }
    options {
        buildDiscarder logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '50', daysToKeepStr: '', numToKeepStr: '1000')
        timeout(time: 2, unit: 'HOURS')
        disableResume()
        durabilityHint 'PERFORMANCE_OPTIMIZED'
        disableConcurrentBuilds()
        skipDefaultCheckout()
        skipStagesAfterUnstable()
    }
    stages {
        stage('node') {
            steps {
                container("docker") {
                    nodeInfo("docker")
                    checkout scm
                }
            }
        }
        stage('base') {
            when {
                anyOf {
                    triggeredBy cause: "UserIdCause"
                    changeset "images/alpine/Dockerfile.alpine"
                }
            }
            steps {
                script {
                    container("docker") {
                        IMAGE = "strongboxci/" + DISTRIBUTION + ":base"

                        sh label: "Building $IMAGE_NAME",
                           script: "${env.WORKSPACE}/build.sh ./images/$DISTRIBUTION/Dockerfile.$DISTRIBUTION"

                        IMAGES.add(IMAGE)
                    }
                }
            }
        }
        stage('jdk8') {
            when {
                anyOf {
                    // should run upon manual build.
                    triggeredBy cause: "UserIdCause"
                    changeset "images/alpine/Dockerfile.alpine"
                    changeset "images/alpine/jdk8/Dockerfile.alpine.*"
                }
            }
            steps {
                container("docker") {

                    script {

                        def files = sh(returnStdout: true, script: '''find ./images/alpine -mindepth 2 -type f -name "*Dockerfile*" | sort | xargs''')
                        println files

                        files.split(" ").each {
                            println it
                            def match = (it =~ /(.*)\\/Dockerfile\.(\w+)(\.(.+))?/)
                            if (match.find())
                            {
                                //println "Building image: ${IMAGE}"
                                // DO NOT USE THIS, BECAUSE IT FAILS WITH `"docker build" requires exactly 1 argument.`!
                                // docker.build(IMAGE, '-f ' + it + ' --no-cache .')

                                def TAG = match.group(4) ? match.group(4) : 'base'
                                def IMAGE = "${IMAGE_NAME}:" + TAG

                                sh label: "Building $IMAGE_NAME",
                                   script: "${env.WORKSPACE}/build.sh $it"

                                IMAGES.add(IMAGE)
                            }
                            else
                            {
                                println "Something went wrong and we could not properly parse ${it} - skipping"
                            }
                        }
                    }
                    echo "jdk test"
                }
            }
        }
        stage('build-tools') {
            when {
                anyOf {
                    changeset "Dockerfile.alpine"
                    changeset "images/jdk/Dockerfile.alpine.jdk8"
                    changeset "images/build-tools/**"
                }
            }
            steps {
                container("docker") {
                    echo "build-tools test"
                }
            }
        }
        stage('deploying') {
            steps {
                container("docker") {
                    echo "Deploying: " + images.join(" ")
                }
            }
        }
    }
}
