@Library('jenkins-shared-libraries') _

def DISTRIBUTION = 'alpine'
def IMAGE_NAME = "strongboxci/" + DISTRIBUTION
def SNAPSHOT = params.getOrDefault("DEPLOY", false);
def TIMESTAMP = (new Date()).format("yyyyddMMHHmmss")
def IMAGES = [];

pipeline {
    agent {
        label "alpine-docker"
    }
    parameters {
        booleanParam defaultValue: false, description: 'Deploy tagged images to docker hub.', name: 'DEPLOY'
    }
    options {
        buildDiscarder logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '50', daysToKeepStr: '', numToKeepStr: '1000')
        timeout(time: 2, unit: 'HOURS')
        disableResume()
        durabilityHint 'PERFORMANCE_OPTIMIZED'
        disableConcurrentBuilds()
        skipStagesAfterUnstable()
    }
    environment {
        TIMESTAMP = "$TIMESTAMP"
    }
    stages {
        stage('node') {
            steps {
                container("docker") {
                    nodeInfo("docker")
                    processDockerfiles("./images/${DISTRIBUTION}/Dockerfile.${DISTRIBUTION}", SNAPSHOT);
                    error "yes."
                }
            }
        }
        stage('base') {
            when {
                anyOf {
                    triggeredBy cause: "UserIdCause"
                    changeset "images/alpine/Dockerfile.${DISTRIBUTION}"
                }
            }
            steps {
                script {
                    container("docker") {
                        def built = processDockerfiles(IMAGE_NAME, SNAPSHOT, "./images/" + DISTRIBUTION + "/Dockerfile." + DISTRIBUTION);
                        IMAGES.plus(built)
                    }
                }
            }
        }
        stage('jdk8') {
            when {
                anyOf {
                    // should run upon manual build.
                    triggeredBy cause: "UserIdCause"
                    changeset "images/${DISTRIBUTION}/Dockerfile.${DISTRIBUTION}"
                    changeset "images/${DISTRIBUTION}/jdk8/Dockerfile.${DISTRIBUTION}.*"
                }
            }
            steps {
                container("docker") {
                    script {
                        def files = sh(returnStdout: true, script: '''find ./images/${DISTRIBUTION}/jdk8 -type f -name "*Dockerfile*" | sort | xargs''')
                        def built = processDockerfiles(files, SNAPSHOT);
                        IMAGES.plus(built)
                    }
                }
            }
        }
        stage('jdk11') {
            when {
                anyOf {
                    // should run upon manual build.
                    triggeredBy cause: "UserIdCause"
                    changeset "images/${DISTRIBUTION}/Dockerfile.${DISTRIBUTION}"
                    changeset "images/${DISTRIBUTION}/jdk11/Dockerfile.${DISTRIBUTION}.*"
                }
            }
            steps {
                container("docker") {
                    script {
                        def files = sh(returnStdout: true, script: '''find ./images/${DISTRIBUTION}/jdk11 -type f -name "*Dockerfile*" | sort | xargs''')
                        def built = processDockerfiles(files, SNAPSHOT);
                        IMAGES.plus(built)
                    }
                }
            }
        }
        stage('publishing') {
            when {
                anyOf {
                    branch 'master'
                    expression { params.getOrDefault("DEPLOY", false) == true }
                }
            }
            steps {
                container("docker") {
                    echo "Deploying images: " + IMAGES.toString()
/*
                    withDockerRegistry([credentialsId: dockerCredentials, url: dockerUrl]) {
                        script {
                            IMAGES.each {
                                sh label: "Publishing ${it}...",
                                   script: "docker push ${it}"
                            }
                        }
                    }
*/
                }
            }
        }
    }
}

def processDockerfiles(String files, Boolean SNAPSHOT)
{
    def BUILD_ARGS = SNAPSHOT ? " --snapshot " : ""
    def images = [];

    files.split(" ").each {
        println it
        def match = (it =~ /(.*)\\/Dockerfile\.(\w+)(\.(.+))?/)
        if (match.find())
        {
            // DO NOT USE THIS, BECAUSE IT FAILS WITH `"docker build" requires exactly 1 argument.` - LIKELY A BUG!
            // docker.build(IMAGE, '-f ' + it + ' --no-cache .')

            def IMAGE_TAG = sh(returnStdout: true, script: '''/bin/bash ${env.WORKSPACE}/build.sh ${BUILD_ARGS} --get-image $it''')

            sh label: "Building $IMAGE_TAG",
               script: "/bin/bash ${env.WORKSPACE}/build.sh ${BUILD_ARGS} $it"

            images.add(IMAGE_TAG)
        }
        else
        {
            println "Something went wrong and we could not properly parse ${it} - skipping"
        }
    }

    return images
}
